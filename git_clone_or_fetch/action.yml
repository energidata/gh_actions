name: git_clone_or_fetch
inputs:
  gh_token:
    required: true
  work_dir:
    required: true
    description: The directory where code is checked out
    default: /opt/shared-workspace/repos
outputs:
  working_directory:
    description: The actual working directory (main repo or worktree)
    value: ${{ steps.setup.outputs.working_directory }}
runs:
  using: "composite"
  steps:
    - name: Update repository
      id: setup
      shell: bash
      run: |
        REPO_NAME="${{ github.event.repository.name }}"
        BASE_DIR="${{ inputs.work_dir }}/${REPO_NAME}/${REPO_NAME}"
        BRANCH_NAME="${{ github.ref_name }}"
        
        # Sanitize branch name for filesystem
        BRANCH_SLUG=$(echo "${BRANCH_NAME}" | sed 's/[^a-zA-Z0-9._-]/-/g')
        
        LOCKFILE="${{ inputs.work_dir }}/${REPO_NAME}/.git.lock"
        mkdir -p "${{ inputs.work_dir }}/${REPO_NAME}"

        exec 200>"$LOCKFILE"

        # Set trap to ensure lock is released on exit (success or failure)
        trap 'flock -u 200' EXIT

        # Progressive lock attempts
        TIMEOUTS=(3 6 12 24 30)
        LOCK_ACQUIRED=false
        for i in "${!TIMEOUTS[@]}"; do
          TIMEOUT="${TIMEOUTS[$i]}"
          ATTEMPT=$((i + 1))
          echo "Attempt $ATTEMPT/${#TIMEOUTS[@]}: Trying to acquire lock (timeout: ${TIMEOUT}s)..."
          if flock -w "$TIMEOUT" 200; then
            echo "Lock acquired on attempt $ATTEMPT"
            LOCK_ACQUIRED=true
            break
          else
            echo "Failed to acquire lock within ${TIMEOUT}s"
            if [ $ATTEMPT -lt ${#TIMEOUTS[@]} ]; then
              echo "Retrying with longer timeout..."
            fi
          fi
        done

        if [ "$LOCK_ACQUIRED" = false ]; then
          echo "ERROR: Failed to acquire lock after ${#TIMEOUTS[@]} attempts"
          exit 1
        fi
        
        # Ensure main repo exists
        if [ ! -d "${BASE_DIR}/.git" ]; then
          echo "GIT CLONE (main repo)"
          cd "${{ inputs.work_dir }}/${REPO_NAME}"
          git clone https://x-access-token:${{ inputs.gh_token }}@github.com/${{ github.repository }} "${REPO_NAME}"
          cd "${BASE_DIR}"
          git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
        fi
        
        cd "${BASE_DIR}"
        git remote set-url origin https://x-access-token:${{ inputs.gh_token }}@github.com/${{ github.repository }}
        git fetch origin --prune

        # Ensure we have the specific commit (for PR merges)
        echo "Fetching commit ${{ github.sha }}"
        git fetch origin ${{ github.sha }} || git fetch origin ${{ github.ref }}
        
        # Determine working directory based on branch
        if [ "${BRANCH_NAME}" = "main" ] || [ "${BRANCH_NAME}" = "master" ]; then
          # Main branch - use main repo
          echo "Using main repository"
          WORK_DIR="${BASE_DIR}"
          git reset --hard HEAD
          git clean -fd -e '.docker-config-*'
          git checkout ${{ github.sha }}
        else
          # Feature branch - use worktree
          WORK_DIR="${{ inputs.work_dir }}/${REPO_NAME}/${REPO_NAME}-worktree-${BRANCH_SLUG}"
          
          if [ -d "${WORK_DIR}" ]; then
            echo "Updating existing worktree at ${WORK_DIR}"
            cd "${WORK_DIR}"
            git reset --hard HEAD
            git clean -fd -e '.docker-config-*'
            git fetch origin
            git checkout ${{ github.sha }}
          else
            echo "Creating new worktree at ${WORK_DIR}"
            cd "${BASE_DIR}"
            git worktree add "${WORK_DIR}" ${{ github.sha }}
          fi
        fi

        # Lock will be automatically released by trap on EXIT

        echo "working_directory=${WORK_DIR}" >> $GITHUB_OUTPUT
        echo "Repository ready at: ${WORK_DIR}"
      env:
        GITHUB_TOKEN: ${{ inputs.gh_token }}


